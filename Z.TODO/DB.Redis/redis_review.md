1. 哈希表变慢是因为什么，怎么办？
2. redis底层数据结构类型都有什么
3. redis使用单线程的原因
4. redis单线程为什么也很快
5. redis持久化的意义
6. AOF如何实现的
7. AOF的回写策略？
8. AOF文件太大怎么办
9. AOF重写的实现方式
10. RDB是什么，作用于什么范围？
11. RDB过程中能进行读写吗
12. RDB能频繁做吗
13. redis同步的过程
14. redis同步时主库有什么变化
15. redis级联复制有意义吗
16. redis同步时网络中断会怎样
17. redis哨兵的作用，工作方式方法都是什么（如何发现彼此，如何连接从库等）
18. 哨兵选主的逻辑，方法
19. 哨兵和客户端之间有什么要说的
20. 分片集群的意义和用处
21. 哈希槽怎么作用的？
22. 客户端对redis cluster，如何定位到数据？









> 1. 哈希表变慢是因为什么，怎么办？
> 随着数据量增多，原有的哈希桶不够用了——不同数据可能会出现相同哈希，这就导致一个哈希桶中有多个数据结果，多个结果之间成为链式哈希，极大的影响效率。redis有rehash机制，当哈希桶和数据的占比高于一定比例时，使用rehash，先扩展一个更大的全局哈希表（一般是当前全局哈希表的2倍），接下来新的数据增加会直接写入到新的全局哈希表，对原哈希表中数据的访问会顺带进行哈希重分布到新的全局哈希表，此外，redis会自动间隔一定时间将原全局哈希表中的数据搬迁至新的全局哈希表，通过增加哈希桶的方式降低链式哈希的情况，提升速度。
>
> 2. redis底层数据结构类型都有什么
> 简单动态字符串，双向链表，整数数组，压缩列表，跳表，哈希表
>
> 3. redis使用单线程的原因
> 多线程并发时，调度和互斥机制对吞吐量影响是很大的，因此用简单的模型，避免复杂的开销
>
> 4. redis单线程为什么也很快
> redis使用单线程机制，对网络IO采用了多路复用机制。通过多路复用，将传入的请求根据事件队列进行分类，redis线程专注于处理请求，因此能够达到非常高效的性能。
>
> 5. redis持久化的意义
> redis重启后内存中的缓存全部丢失，需要重建缓存往往需要调用后端数据库进行数据查询，这个过程中会对后端造成较大压力，也会因耗时较多影响服务恢复时间。通过持久化机制，将缓存数据落盘，减少恢复时间的开销，也降低了重新缓存对后端造成的压力。
>
> 
>
> 6. AOF如何实现的
> redis执行数据变更后，会将变更动作写入AOF文件。出于性能和无阻塞考虑，写入AOF文件的命令不会进行语法检查，因此在命令执行成功后记录AOF能够避免有语法检测带来的阻塞和没有语法阻塞导致语法错误的命令被写入AOF。
> AOF回放时会根据文件中记录的动作逐步执行，以恢复数据。
>
> 7. AOF的回写策略？
> 三种策略，每次新增记录都立即落盘；新增记录写入AOF buffer， 每一秒进行一次落盘； 新增记录写入AOF buffer，由操作系统决定何时fsync。
> 立即落盘安全性最好，但落盘驱动磁盘IO较慢，对redis主线程的阻塞影响也是最大的；
> 由操作系统决定落盘的性能最好，但实例失败后会导致丢失较多的记录；
> 每秒进行一次落盘是一个这种方案，对主线程阻塞较少，且实例崩溃后最多丢失1秒的记录。
>
> 8. AOF文件太大怎么办 & 9. AOF重写的实现方式
> redis有AOF重写机制，将AOF重写，重写后文件中仅仅记录着数据记录的最新版本状态，因此文件体积会显著减小。
> AOF重写，主线程会fork一个子线程负责AOF重写，同时会将主线程的内存页映射表复制给子线程一份，子线程因此可以访问主线程的所有内存记录页。开始重写，子线程通过内存页映射表对数据最新版本进行AOF日志重写，这个期间新增的数据变更动作会通过写时拷贝特性，由主线程复制数据页后，申请新的内存空间，并在新的内存空间中完成数据变更。此时AOF文件和AOF重写都会记录到AOF buffer 并按照策略落盘，即使重写失败，原AOF文件依然存在，不会因此丢失AOF文件记录。
>
>
> 10. RDB是什么，作用于什么范围？
> 与AOF不同的是，RDB是redis主线程内存页中全部数据的二进制快照。
>
> 
>
> 11. RDB过程中能进行读写吗
> RDB是主线程会fork一个子线程，同样复制内存页映射表和写时复制，来完成对内存的快照， 快照过程中新增的变更会通过写时复制记录到额外的内存页中， 不会影响快照范围内的数据状态。
>
>
> 12. RDB能频繁做吗
> 虽然RDB操作不会影响服务，但是主线程fork子线程是会短暂的阻塞主线程的， 而且这个阻塞时长与redis内存中的数据量正相关，频繁执行RDB也会因磁盘IO的吞吐量造成阻塞、争用， 因此不建议过于频繁的发起RDB操作。 
> RDB和AOF可以结合使用，避免了RDB后数据变更的记录缺失， 也极大的缩短了AOF回放的时长，是一个比较平衡的混合方案。
>
>
> 13. redis同步的过程
> 从库向主库发起同步请求，请求内容中包含了主库ID和偏移量，但初次同步时，主库ID为未知，偏移量也为空。主库收到请求后，返回自己的ID和当前偏移量，并同时进行一次RDB并传送给从库，建立同步复制，主库会在内存中开辟两个缓存空间，一个用来记录需要同步出去的数据变更记录，另一个环形缓冲用来提供主库记录写偏移量、从库记录读偏移量。
> 从库接受到RDB快照后，会先清空自己的数据，而后恢复RDB快照，自此开始向主库发起自己的读偏移量，并接收、应用主库发来的变更记录。
>
>
> 14. redis同步时主库有什么变化
> 只要有从库，主库便会将数据变更记录到复制缓存中，同时在环形缓存中记录自己的写偏移量。如果从库应用较慢，导致环形记录中的读偏移量追不上主库的写偏移量时，当主库写满了环形缓存，便可能覆写缓存，导致从库偏移量记录丢失，此时从库只能从主库进行全量同步。
>
>
> 15. redis级联复制有意义吗
> 建立同步时，主库会进行一次RDB操作，RDB操作需要fork子进程，这个fork动作会短暂阻塞主线程引发性能瞬时下降，当从库较多时，主库会多次发生RDB，因此影响比较明显。 可以通过级联复制的方式， 将RDB开销由从库进行，减少了主库阻塞的情况。
>
> 16. redis同步时网络中断会怎样
> 网络中断后，主会将变更继续写在环形缓存中， 当从库恢复连接时，发送的偏移量与环形缓存中对比后，主库会返回缺失的记录。如果中断过久，导致环形缓存写满，那么主库会覆写环形缓存， 覆写后从库重新连接，由于读偏移量丢失，只能重新发起全量同步。
>
> 
>
>
> 17. redis哨兵的作用，工作方式方法都是什么（如何发现彼此，如何连接从库等）
> 哨兵用来监控，选主，通知。
> 哨兵按照一定时间间隔向实例发送ping探活。超时未响应便引起主观下线，如果是主库超时引起主观下线，哨兵会对主库下线发起投票，投票超过quor值则主库判定为客观下线，这回开始选主，选出新主后，哨兵通知各从库和客户端新的主库地址。
>
> 哨兵配置本身只有主库地址，哨兵角色的彼此发现依赖于redis的发布、订阅机制，上线的哨兵会向频道发布自己的上线信息，并以此发现彼此并建立连接。
> 哨兵通过查询主库得到从库地址，再连接从库进行监控。
>
>
> 18. 哨兵选主的逻辑，方法
> 当哨兵发现主未应答后，会发起一个主观下线的投票，哨兵集群中其他节点会根据各自哨兵的探测结果参与主观下线投票 ，如果投票达到quora参数设置的值，则投票生效，原主被标记为客观下线。
> 哨兵此时发起哨兵leader的竞选，得票数过半则赢得竞选，开始主持选主工作，
> 选主会先判断各从库的网络历史状态，而后采用积分制度， 优先级最高的会直接当选新主，优先级一致的，会判断各从库的复制偏移量， 偏移量最远也就是数据最新的会直接当选新主，数据版本也一致的，会判断实例ID，实例ID最小的会当选为新主。
>
>
> 19. 哨兵和客户端之间有什么要说的
> 客户端需要订阅哨兵的一些消息，来获取新主信息，在重新选主后直接得到新主地址，进行访问。
>
>
> 20. 分片集群的意义和用处
> 当redis中数据量非常多的时候，RDB等操作的阻塞时间与数据量成正相关， 而且当数据量继续增长时，垂直扩容的代价会越来越高，收益越来越低，持久化成本也越来越高。
> 使用分片集群，将数据打算、分片分布到不同的实例中，每个实例的数据量变得可以接受， 持久化代价变低，而且水平扩容的弹性要远高于垂直扩容。非常适合大数据量的场景。
>
>
> 21. 哈希槽怎么作用的？ & 22. 客户端对redis cluster，如何定位到数据？
> redis cluster 有16384个哈希槽，对应16384个分片。这些哈希槽会均匀的分布在集群内所有实例中， 也可以按照情况手动指定分配到集群内的所有实例中。当数据插入时，会对key与16384取模，得到分配的哈希槽，分配到对应实例。
> 每个实例初始只了解自己所分配的哈希槽，但通过向集群内其他实例通信、发布自己的哈希槽分配表，最终集群内每个实例都有完整的哈希槽分配表。
> 当集群内增减实例，或出于均衡考虑进行哈希重分布时，哈希槽和实例的对应关系都会有变化，这个变化也会随着实例间的发布和通信，实时更新。
> （22. 客户端对redis cluster，如何定位到数据？）
> 客户端连接redis cluster时，会先获取到哈希槽分配表并缓存到客户端本地，之后发生数据操作请求时，客户端本地对数据取模后便可以根据缓存的哈希槽分配表找到对应存储所需数据的实例。但当集群中哈希槽记录表与实例的对应发生变更时，并不会通知给客户端，此时客户端请求的数据如果已经不在原来的对应实例中， 客户端会受到moved操作，返回数据当前所在的实例地址，客户端根据该返回信息重新请求即可得到数据，同时会更新本地缓存的哈希槽分配表。
> 但是有一种时候，迁移尚未完成，请求的数据部分在原实例中，部分已经迁移走，客户端会受到ASK错误，提示数据被部分迁移中，此时客户端可以执行ASKING，向新实例进行数据请求，但该动作不会刷新客户端本地缓存的的哈希槽分配表中，也就是下一次再请求原本在原实例的数据， 依然仅仅会向原实例请求（而不是去新实例去请求）。