> \* 记得考虑MVCC，快照读、当前读对undo的调用逻辑

client发起查询请求，server层通过连接器对权限进行验证后，由解析器对语义语法进行验证及SQL解析。老版本开启QC的话会优先去QC中查找缓存结果。完成解析后由优化器对请求进行改写优化，并生成执行计划。执行器根据执行计划，操作引擎层以返回查询结果。

innodb层收到请求后，会先检查需要读取的数据是否存在IBP的data pages 中。

如果不存在则调用IO读innodb表空间，并将需要的数据读取到IBP的data pages中——如果change buffer中有这些数据的修改缓存，那么会在这时被合并到IBP(update/delete)，或直接加载到IBP(insert)。

如果查询请求为快照读，当事务隔离级别为RC时，事务中的每次查询都会根据当前数据创建一次快照版本，这就是不可重复读。当事务隔离级别为RR时，事务的第一次有效读时会将当前数据创建全局快照，在本次事务结束前的每一次读请求都不会重新创建快照，这就是可重复读。

如果查询请求为当前读，会读已提交的最新版本并加锁。IS锁阻塞符合条件行的修改，IX锁阻塞符合条件的一切其他锁但不会阻塞快照读。

快照的生成建立在MVCC机制上，MVCC通过undo和事务id控制多版本，通过行级锁控制并发。依靠undo保存旧版本数据，再利用回滚段指针查找旧版本数据，查找过程中根据事务ID和隔离级别判断数据版本可见性并查找到可见的版本。

每行记录有三个隐藏列：row_id、事务id、回滚段指针。

> 其中row_id在没有显式创建聚集索引时才会分配，如果有显式创建聚集索引、非空的唯一索引，那么就不存在row_id。
>
> 事务ID是一个递增值，每开启一个事务便生成一个新的事务ID，事务ID是一条数据多次更新的时间点，类似时间戳的概念。可以理解为数据最后一个版本的id。
>
> 回滚段指针对应着事务id和该事务id更新之前的版本。在更新之前，innodb先将旧数据复制到undo，然后回滚段指针指向undo的这个位置，再将这个指针存储在这条数据最新版本的头部信息里。

当需要创建快照时，如果当前事务未提交，隔离级别大于等于RC的其他事务，是不会看到当前未提交的数据，而应该读取到已提交的老版本数据。MVCC多版本构建机制为：通过回滚段指针（roll_ptr）找到对应的undo log版本，然后根据事务id来判断该版本记录的可见性，如果不可见，则继续向前查找更旧的事务ID，直到找到符合可见性条件的记录。