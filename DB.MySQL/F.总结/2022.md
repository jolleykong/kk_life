- list
  - MRR
  - BKA
  - ICP
  - MVCC
  - change buffer
  - doubleWrite
  - update流程
  - select流程
  - 锁类型
    - insert as select 怎么加锁
    - 等值条件怎么加锁
    - 等值范围怎么加锁
    - 范围怎么加锁
  - ckpt怎么触发
  - 两阶段提交
  - 幻读和不可重复读区别
  - RR是如何避免幻读的？
  - xb备份流程
  - mysqldump备份流程



## MRR

多范围读。

使用二级索引时，通过主键排序，再顺序读取。避免了随机IO的低效，也避免了频繁离散读导致内存中页被意外置换。

- 读取二级索引结果到buffer
- 在buffer中根据主键排序
- 根据排序结果去回表读结果

## BKA

BKA要使用 join buffer，BKA要求join的表有索引。

1. 对于多表join语句，当MySQL使用索引访问第二个join表的时候，使用一个join buffer来收集第一个操作对象生成的相关列值。
2. BKA构建好key后，批量传给引擎层做索引查找。key是通过MRR接口提交给引擎的（MRR目的是较为顺序）MRR使得查询更有效率。

buffer越大，访问被join的表/内部表就越顺序。

## ICP
ICP只适用于二级索引。
索引检索三个阶段：index key，index filter，table filter，后两者都是由引擎层执行index key 后，将结果传给server层再进行的。
ICP可以将 index filter 过程下推Pushdown到引擎层进行过滤，再将结果返回给server层进行table filter过滤过程。
减少了回表与返回server层的记录交互开销。

## MVCC
mvcc每个版本存放的是整条数据。
mvcc并发控制靠行锁，版本数据靠undo，数据版本可见性靠事务ID。
当数据被修改前，会将数据的原始版本复制一份到undo log中，并将undo log的地址指针更新到数据行的行头中。
进行数据访问时，根据事务隔离级别决定查找怎样版本的数据。当旧版本的数据对当前事务不可见时，就继续向前查找更旧的事务ID，直到找到对当前事务可见的事务ID，获取该ID对应的版本数据。
> RR时，这种判断方法不需要拿当前事务ID去与表中每行数据的事务ID做比较，只需要在事务开始前先将当前数据库中所有的活跃事务以及read view快照创建一个列表，根据最早的事务ID和最晚的事务ID做比较，当前事务开启时还未提交的其他事务，以及当前事务开启后才开启的其他事务，对当前事务都不可见。


## change buffer
将对二级索引的更新操作由散列操作整理为顺序IO操作。
对唯一索引或主键索引的DML，是直接修改索引树、追加索引树，因为值具有唯一性。
对二级索引进行DML操作时，并不是直接操作数据。因为二级索引不具备唯一性，因此在维护索引树的过程中IO为散列IO，在大量数据DML时，对索引树的维护造成的IO开销会非常低效。
对二级索引的DML，首先将变更记录到change buffer 中（而不是先随机IO读入页到内存再修改），同时将变更动作记录到redo log。
当其他操作将受影响的页读入IBP时（此时认为页的读入是顺序IO），change buffer中该页的修改再merge到IBP；或当数据库被认为空闲/IBP空间不够用/数据库正常关闭/redo写满时，将change buffer的数据落盘。

## doubleWrite
innodb 一个page默认是16K，而OS层面的块是4K，这样当将内存页落盘过程中发生意外时，就有可能造成部分数据块写入不完整，导致数据不可逆的损坏。redo只记录了逻辑操作，并不包含物理块，并不能从redo中恢复数据。双写由磁盘空间和内存空间共同组成，一共2M。在脏页落盘前，会先将脏页顺序写到双写，双写完成落盘后，再进行脏页刷盘。保证了双写先于脏页刷盘而落盘，这样当刷新脏页出现意外丢失时，可以直接从落盘的双写中将脏页恢复出来。

## update流程

## select流程

## 锁类型

## insert as select 怎么加锁

## 等值条件怎么加锁

## 等值范围怎么加锁

## 范围怎么加锁

## ckpt怎么触发

## 两阶段提交

## 幻读和不可重复读区别

## RR是如何避免幻读的？

## xb备份流程

## mysqldump备份流程

## 组提交实现原理

## 并行复制

## 增强半同步和半同步区别

## InnoDB行锁实现机制