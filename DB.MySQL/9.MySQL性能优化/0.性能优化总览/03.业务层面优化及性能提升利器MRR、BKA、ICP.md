# 业务层面优化

## SQL优化

[SQL优化公开课](ke.qq.com/course/411889)

- 多用简单SQL

- （不熟悉子查询时）少用子查询

  > 5.7以前 exists 子查询是不能优化的，直到8.0。

  

- 少用复杂表JOIN，并且要注意JOIN的方式

  > 多表join时，驱动结果集小的表放前面（也就是所谓驱动表的概念了，但是不要单纯用表大小来判断，用结果集判断。另外order by的话，将order by 列的结果集的表放在前面）

  

- where条件中不适用函数、表达式，可通过虚拟列变通实现。

- 注意类型隐式转换

- 固定业务逻辑封装成存储过程。但是存储过程可能影响未来分库分表、读写分离架构。

- ~~select count(*) from tab_innodb;~~

  > 对于InnoDB表，`count(*)`并不好，所以尽量不要`count(*)`
  >
  > 尽管MySQL 5.7开始对count(*)做了优化，但是依然不完美。

  

- 错误的使用limit限制结果集大小

  > limit 不要做大跨越，如：
  >
  > 错误示范：limit 1000000, 20 ;   从1000000开始取20条
  >
  > 1. where过滤，
  >
  > 2. 然后扫描前1000000条记录
  >
  > 3. 然后跳过这100w条记录，再去20条记录
  >
  >    效率特别低，可以用 where pk_id >= 1000000 limit 20;来优雅的实现

  

- 分页改成基于主键的JOIN或子查询

- 动态改成静态，或者降低更新频率

- 从产品端小件不必要的业务



## 业务、逻辑优化

- 以下场景，现在redis或memcached中缓存，再定时从持久化存储
  - 游戏中位置移动，或技能背包、物品增加等
  - 过节时人们的短信或祝福行为
  - 文章访问次数增加每次加1
  - 用户登录记录每次加1
  - 限额业务每次使用加1




