# redis 事务

命令

```
multi
[commands...]
exec
```

- 按照queue的顺序执行事务内的命令。
- 事务内的命令执行时，不会被其他命令中途插入执行。



## 错误处理

- 语法错误
  - 指令不存在或命令参数的个数不对
  - 事务中存在语法错误的，执行exec时，redis会直接报错，事务内的任何语句都不会被执行。
- 运行错误
  - 命令执行时出现错误，如用错了类型命令操作其他类型的数据。
    - 这种错误在命令实际执行前redis无法发现。
    - 因此会被redis先执行再抛出错误
  - 事务中存在运行错误的，事务里其他的命令会继续执行（包括出错命令之后的正确命令）



## 事务回滚

- redis虽然有事务，但是不支持事务回滚。
- 如果事务执行后需要回滚到执行前的状态，只能手动整理逻辑去修改了。
- 语法错误完全可以在执行前进行发现并解决
- 运行错误完全可以通过规范键名规则来避免命令与数据类型不匹配的情况。



## watch命令

```
watch key

unwatch
```



- watch用来当被监控的键被修改后阻止之后的一个事务的执行。

  - 但是不保证其他客户端不修改这一键
  - 因此在exec失败后需要重新执行整个函数。

- 监控一个或多个键，监控持续到exec命令。

  - 执行exec命令后会取消对所有键的监控。
  - 不想执行事务中的命令可以用unwatch命令取消监控。

- 监控开始后，一旦被监控键中有一个键被修改或删除，那么**之后的事务**就不会被执行。

  > ```
  > 127.0.0.1:6379> set key 1
  > OK
  > 127.0.0.1:6379> set key 2
  > OK
  > 127.0.0.1:6379> watch key
  > OK
  > 127.0.0.1:6379> set key 3
  > OK
  > 
  > # watch后开启一个包含watch键，也包含其他键操作的事务
  > 127.0.0.1:6379> multi
  > OK
  > 127.0.0.1:6379> set k 1
  > QUEUED
  > 127.0.0.1:6379> set k 2
  > QUEUED
  > 127.0.0.1:6379> set key 4
  > QUEUED
  > 127.0.0.1:6379> exec
  > (nil)
  > 
  > # 可以看到，事务也不会被执行。
  > 127.0.0.1:6379> get k
  > (nil)
  > 127.0.0.1:6379> get key
  > "3"
  > ```
  >
  > ```
  > 127.0.0.1:6379> get key
  > (nil)
  > 127.0.0.1:6379> get k
  > (nil)
  > 
  > 127.0.0.1:6379> set key 1
  > OK
  > 127.0.0.1:6379> watch key
  > OK
  > 127.0.0.1:6379> set key 2
  > OK
  > 
  > # watch被修改后，开启一个与watch键无关的事务
  > 127.0.0.1:6379> multi
  > OK
  > 127.0.0.1:6379> set k 1
  > QUEUED
  > 127.0.0.1:6379> set k 2
  > QUEUED
  > 127.0.0.1:6379> exec
  > (nil)
  > 
  > # 可以看到，事务也不会被执行。
  > 127.0.0.1:6379> get k
  > (nil)
  > 127.0.0.1:6379> get key
  > "2"
  > ```
  >
  > 