# 列表类型 list

- 双向链表，因此从头、尾读取x个数据的性能不受总数据量影响
- 使用链表的代价是通过索引访问元素比较慢





## 命令

### 列表两端增加元素 lpush/rpush

返回值为增加后的列表长度

```
lpush <key> value [<value>..]
rpush <key> value [<value>..]
```

>127.0.0.1:6379[1]> rpush l1 1 2 3 4 5
>(integer) 5



### 列表两端删除元素 lpop/rpop

返回值为删除的元素

```
lpop <key>
rpop <key>
```

> ```
> 127.0.0.1:6379[1]> lpop l1
> "1"
> 127.0.0.1:6379[1]> lpop l1
> "2"
> ```



### 获取列表元素个数 llen

```
llen <key>
```

> ```
> 127.0.0.1:6379[1]> llen l1
> (integer) 3
> ```



### 获得列表切片 lrange

```
lrange <key> <start> <stop>
```

> ```
> 127.0.0.1:6379[1]> lrange l1 0 2
> 1) "3"
> 2) "4"
> 3) "5"
> 
> 127.0.0.1:6379[1]> lrange l1 0 -2
> 1) "3"
> 2) "4"
> 
> 127.0.0.1:6379[1]> lrange l1 0 -1    # 获取所有元素
> 1) "3"
> 2) "4"
> 3) "5"
> ```



### 删除列表中指定值 lrem

```
lrem <key> <count> <value>
```

- count>0时，会删除列表前count个值为value的元素（即：从左向右）
- count<0时，会删除列表后count个值为value的元素（即：从右向左）
- count=0时，删除所有值为value的元素

> ```
> 127.0.0.1:6379[1]> lrem l3 2 1
> (integer) 2
> 127.0.0.1:6379[1]> lrange l3 0 4
> 
> 1) "2"
> 2) "2"
> 3) "3"
> 4) "3"
> 5) "2"
> 127.0.0.1:6379[1]> lrange l3 0 -1
> 6) "2"
> 7) "2"
> 8) "3"
> 9) "3"
> 10) "2"
> 11) "2"
> 12) "1"
> 13) "1"
> 
> 127.0.0.1:6379[1]> lrem l3 -2 1
> (integer) 2
> 
> 127.0.0.1:6379[1]> lrange l3 0 -1
> 14) "2"
> 15) "2"
> 16) "3"
> 17) "3"
> 18) "2"
> 19) "2"
> ```



### 获取/设定指定索引的元素值 lindex/lset

```
lindex <key> <index>
lset <key> <index> <value>
```

> ```
> 127.0.0.1:6379[1]> lrange l3 0 -1
> 1) "2"
> 2) "2"
> 3) "3"
> 4) "3"
> 5) "2"
> 6) "2"
> 127.0.0.1:6379[1]> lindex l3 0
> "2"
> 127.0.0.1:6379[1]> lset l3 1 a
> OK
> 127.0.0.1:6379[1]> lrange l3 0 -1
> 1) "2"
> 2) "a"
> 3) "3"
> 4) "3"
> 5) "2"
> 6) "2"
> ```

### 只保留列表指定片段 ltrim

Ltrim 会删除指定索引之外的所有元素

```
ltrim <key> <start> <end>
```

> - 可以发现，保留了指定的两个边界索引元素
> ```
> 127.0.0.1:6379[1]> lrange l3 0 -1
> 1) "2"
> 2) "a"
> 3) "3"
> 4) "3"
> 5) "2"
> 6) "2"
> 127.0.0.1:6379[1]> ltrim l3 2 4
> OK
> 127.0.0.1:6379[1]> lrange l3 0 -1
> 1) "3"
> 2) "3"
> 3) "2"
> ```
>



ltrim和lpush结合使用，可以一起来结合使用限制索引中元素数量：

lpush后通过ltrim操作，始终限制元素数量，适合如保留队列长度等需求。



### 向列表中插入元素 linsert

- 从列表左向右查找值为search的元素，然后根据after|before 来决定将新value插入到这个元素的位置。

- 返回值为插入后列表元素的个数

```
linsert <key> <before|after> <search> <value>
```

> - 可以看到，插入在找到第一个匹配元素的前面了。
>
> ```
> 127.0.0.1:6379[1]> lrange l3 0 -1
> 1) "3"
> 2) "3"
> 3) "2"
> 127.0.0.1:6379[1]> linsert l3 before 3 a
> (integer) 4
> 127.0.0.1:6379[1]> lrange l3 0 -1
> 1) "a"
> 2) "3"
> 3) "3"
> 4) "2"
> ```



### 将元素从一个列表转到另一个列表 rpoplpush

```
rpoplpush <source> <target>
```

- 先执行rpop从source列表中弹出最右的元素，再将该元素插入到target列表的左边，并返回这个元素的值。
- 整个操作是原子的

- 把列表当做队列使用时，rpoplpush可以很直观的在多个队列中传递数据。
- 当target和source相同时，rpoplpush会不断地将队尾的元素插入到队首
- rpoplpush在执行过程中，仍然可以不断地向队列中加入新元素。容易扩展。

> ```
> 127.0.0.1:6379[1]> rpoplpush l4 l4
> "1"
> 127.0.0.1:6379[1]> rpoplpush l4 l4
> "2"
> 127.0.0.1:6379[1]> rpoplpush l4 l4
> "3"
> 127.0.0.1:6379[1]> rpoplpush l4 l4
> "1"
> 127.0.0.1:6379[1]> rpoplpush l4 l4
> "2"
> 127.0.0.1:6379[1]> rpoplpush l4 l4
> "3"
> 127.0.0.1:6379[1]> rpoplpush l4 l4
> "1"
> 127.0.0.1:6379[1]> rpoplpush l4 l4
> "2"
> 127.0.0.1:6379[1]> rpoplpush l4 l4
> "3"
> ```
>
> 
