'''
class A:
    
    company_name = '老男孩教育'  # 静态变量(静态字段)
    __iphone = '1353333xxxx'  # 私有静态变量(私有静态字段)


    def __init__(self,name,age): #特殊方法

        self.name = name  #对象属性(普通字段)
        self.__age = age  # 私有对象属性(私有普通字段)

    def func1(self):  # 普通方法
        pass

    def __func(self): #私有方法
        print(666)


    @classmethod  # 类方法
    def class_func(cls):
        """ 定义类方法，至少有一个cls参数 """
        print('类方法')

    @staticmethod  #静态方法
    def static_func():
        """ 定义静态方法 ，无默认参数"""
        print('静态方法')

    @property  # 属性
    def prop(self):
        pass
'''

# 面向对象：
# 是相似功能的集合。将相关函数、功能放到一个class，对代码进行有条理的分类。
# 站在上帝的角度去抽象思维。得到对象就能得到一切。

# 对象：类的具体表现。

# 类的结构：
    # 类名要具有可描述性， 以驼峰体命名格式
    # 类的静态属性
    # 类的方法

# 从类名角度研究类
    # 获取类所有信息 __dict__
    # 通过类名操作类的属性（内部、外部、派生类）
    # 调用类里的方法
        # 静态方法 类方法 通过类名调用（只能）。
        # 其他方法主要通过对象来调用。

# 从对象角度研究类
    # 对象也叫实例
    # 类名+() 产生一个实例， 也叫实例化对象过程
    # 过程：
        # 先通过object.__new__ 在内存中为对象开辟内存空间
        # 再执行类的__init__方法， 把对象传入对象空间
        # 通过__init__ 方法， 为对象封装属性

    # 对象.属性名           来给对象自己封装属性、操作属性
    # 对象.__dict__        查看自己对象空间内的所有属性
    # 对象.类中的静态变量名   查看类的静态属性
    # 对象.类中的方法名      调用类的实例方法（隐性传参self）


# 从空间角度研究类
    # 通过类名可以在类内外封装属性
    # 通过类内外可以为对象封装属性

    # 对象查询一个属性：
        # 对象空间 > 类空间 > 父类空间

    # 类查询一个属性：
        # 类空间 > 父类空间

    # ↑ 单向不可逆原则。对象与对象之间互相独立（除去组合这种特殊的关系之外）。

# 类与类的关系
    # 1.依赖关系
    # 2.组合关系（关联组合聚合）
        # 组合关系：将一个类的对象封装成另一个类的对象的属性。
    # 3.继承关系
        # B继承A类，B就叫做A的子类、派生类。 A叫做B的父类，基类，超类。
        # B类及B类对象使用A类的所有的属性以及方法。

        # 继承优点：
            # 1.减少代码量
            # 2.提升耦合性
            # 3.代码规范化

        # 单继承： 只有一个父类。
            # 使用.调用子类以及对象，可以调用父类的属性及方法。（也只能调用，不能操作父类的属性及方法。）
            # 从类名执行父类的属性
            # 从对象执行父类的一切
            # 子类将父类方法覆盖重写
            # super()方法：
                # super() 严格意义并不是执行父类的方法。
                # 单继承时，super() 肯定是执行父类的方法
                # 多继承时，super(S,self) 严格按照self从属于的类的mro()的顺序（即：self从属于的类.mro()）执行“S类的下一位”。

        # 多继承： 有多个父类。有区别.调用
            # 多继承的难点是继承顺序的问题。
            # mro()
            # 经典类：基类不继承object，查询规则依靠：深度优先 的原则。
            # 新式类：基类必须继承object，查询规则依靠：mro算法。 MRO（Method Resolution Order）：方法解析顺序

# 多态
    # 鸭子类型：py中，你看起来像鸭子，那么你就是鸭子。如：一条狗，看起来像鸭子，走路也像鸭子，那么它就是鸭子。

# 类的约束
    # 在一些重要的逻辑，与用户数据相关等核心部分，要建立一种约束，避免发生混乱错误。
    # 类的约束有两种解决方式：
        # 1. 在父类建立一种约束
            # 定义方法并设定except
        # 2. 模拟抽象类（指定一种规范）的概念，建立一种约束。
            # from abc import ABCMeta,abstractclassmethod

# 类的私有成员
    # 类的私有成员(私有类属性及私有方法，私有对象属性)
        # 1.在类的内部可以访问
        # 2.类的外部不能访问
        # 3.派生类也不能访问父类的私有成员
        # 适用于密码、重要数据等不想被其他引用的属性\方法
    # python所有的私有成员都是纸老虎，并不安全。
        # 实际上通过__dict__ 来查看，是可以看到私有成员只是被内部重命名了。（_类名+对象名）
        # 因此，私有成员不要去引用，约定俗成的君子协议罢了。

# 类的其他方法
    # 静态方法 @staticmethod
        # 静态方法。不依赖对象不依赖类，其实就是普通的函数。
        # 但是静态方法也需要使用类来调用。
        # 跟在类外定义的函数一毛一样，但是为什么在类中定义呢？ 方便管理，保证规范性，按照功能区划分规划。。
            # 类中包含所有相关功能的定义，静态方法不依赖类中任何内容罢了。
    # 类方法 @classmethod
        # 顾名思义：一般是通过类名去调用的方法。
        # 类方法调用
            # 和实例方法的区别是，通过类名调用方法，不需要显式传参。
            # 通过类名调用实例方法，必须要显式传参self才能执行。
                # 可以看到，cls始终传的是类名
                # 而对象方法中self始终传的是类名地址
                    # 通过cls拿到类名有什么用？
                        # 有类名就可以用来实例化对象！
                            # 就可以在class 的function中直接以cls()的方式实例化对象
                        # 可以通过类名操作类的属性


# 属性 @property , @<funName>.setter , @<funName>.deleter 
    # 一些情况下 方法名看起来像属性时， 就可以用property来将方法名伪装成属性。
    # property将执行一个函数需要 函数名() 直接变成 函数名执行
    # property将动态方法伪装成了一个属性，在代码层面上没有提升，但是看起来会更加合理。


# 类与类之间的关系判断 isinstance、issubclass
    # 判断对象与类之间的关系 isinstance 。
        # isinstance(a,b) 判断a是否是b类，或b类的派生类 的实例化对象。
    # 判断类与类之间的关系 issubclass 
        # issubclass (a,b) 判断a是否是b类，或b类的派生类 的派生类。（判断a是否是b的子孙类）
        

# type元类
    # python中一切皆为对象，类在某种意义上也是一个对象。
        # python中由自己定义的类以及大部分内置类，都是由type这个元类实例化得来的。
        # 也有少部分不是由type实例化得来的，这是例外情况，如工厂类等。少见。
    # object类 是type类的一个实例 && object类 是 type类的父类。
        # 有些乱，但是到此为止。 鸡蛋和鸡之间的关系了。

# 反射
    # 反射： 程序对自己内部代码的一种自省方式。
    # 是通过字符串去操作对象的方式。

    # 一切皆对象， 4个维度。 反射也只能用于这4个维度。
        # 实例对象  （很少）
        # 类    （最常用）
        # 本模块    （次次常用）
        # 其他模块  （次常用）

    # 4个方法，组成反射
        # hasattr  (常用)
        # getattr  (常用)
        # setattr
        # delattr

# 函数和方法的区别区分
    # 函数都是显性传参，方法都是隐性传参！
        # python中一切皆对象，类在某种意义上也是一个对象，python中自定义的类以及大部分内置类，都是由type元类（构建类）实例化得来的，
        # python中一切皆对象，函数在某种意义上也是一个对象，函数这个对象是从FunctionType这个类实例化出来的。
        # python中一切皆对象，方法在某种意义上也是一个对象，方法这个对象是从MethodType这个类实例化出来的。
    # 函数就是函数。function
    # 通过类名调用类中的实例方法， 叫函数。function
    # 通过对象调用的类中的实例方法，叫方法 method

    # Java中只有方法， C中只有函数， C++取决于是否在类中， Python看传参！（因为有静态方法）

# 特殊的双下方法
    # __len__   
        # len() 一个字符串时，就是触发了字符串从属于的类中定义的 __len__ 方法

    # __hash__  
        # hash() 一个字符串时，就是触发了字符串从属于的类中定义的 __hash__ 方法

    # __str__   
        # print 触发 __str__ ，str() 触发 __str__

    # __repr__
        # repr和 str 很像， 也被print触发。
        # 那么str和repr的优先级 ———— str优先级高于repr

    # __call__
        # 对象名+() 会自动触发对象从属于类或父类的__call__ 方法

    # __eq__
        # 进行==判定时触发

    # __del__

    #  __new__
        # __new__  十分重要。 new一个对象。
        # 类名+() 就会产生一个对象，然后对象执行__init__
        # __new__ 在内存中开辟一块对象空间，然后将__init__ 执行，创建在对象空间内。


    # __item__系列
        # 对对象进行字典类操作，会触发__item__系列方法
        # __getitem__
        # __setitem__
        # __delitem__

    # 上下文管理器相关 __enter__  __exit__
        # 另一种实例化对象的方法需要用到
        # 实例化对象时先触发__enter__ ，然后指定实例化动作中指定的代码，最后触发__exit__ 

# 单例模式
    # python的设计模式之一。
    # 单例模式：一个类只允许实例化一个对象。
    # 让类实例化对象之后，再次执行实例化，则直接返回第一次实例化的对象地址

