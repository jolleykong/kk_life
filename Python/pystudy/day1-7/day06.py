# is == id 用法
# 代码块
# 同一代码块下的缓存机制
# 不同代码块下的缓存机制（小数据池）
# 总结
# 集合
    # 交并差（重要）
# 深浅copy

# is == id 用法
    # 如果两个东西的id相同，那么这两个变量的值一定相同(这两个东西就是一个东西)
    # 对于不可变对象，相同的对象在内存中地址相同。
    # 对于可变对象，相同的对象在内存中地址不会一样。
        # >>> l1 = 'a'
        # >>> id(l1)
        # 4345988976
        # >>> l2 = 'a'
        # >>> id(l2)
        # 4345988976
        # >>> l1 = [1,2,3]
        # >>> l2 = [1,2,3]
        # >>> id(l1)
        # 4346870592
        # >>> id(l2)
        # 4346894592
    # *is 判断的是内存地址是否相同*
        # >>> l1 = 'a'
        # >>> l2 = 'a'
        # >>> l1 is l2
        # True
        # >>> l3 = ['a']
        # >>> l4 = ['a']
        # >>> l3 is l4
        # False

# 代码块
    # py的代码块是一个py程序的文本，作为一个执行的单元。
    # 一个函数、交互模式下的一行命令、一个文件就是一个代码块（在同一个文件里）。
    # 同一个代码块下有一个缓存机制，不在同一个代码块下有另一个缓存机制。
# 同一代码块下的缓存机制（字符串驻留机制）
    # '''
    # py在执行同一个代码块的初始化对象的命令时（初始化对象的命令：就是声明变量。），会检查其值是否已经存在。如果存在会将其重用。
    # 也就是说，执行同一代码块时，遇到初始化对象的命令时，会将初始化的这个变量与值存储在一个字典中，
    # 遇到新的变量时，会先在字典中查询记录，如果有同样的记录则会重复使用这个字典中存在的那个值（就是两个变量指向同一个对象）。
    # 满足缓存机制则他们在内存中只存在一个，即：id相同。
    # 适用对象：int(float)，str，bool
    # 目的：节省内存，提升性能（避免了创建和销毁的开销）。
    # 所有的数字、布尔值和几乎所有的字符串（通过乘法得到的字符串，乘数==1时可以满足代码块缓存机制；或乘数>=2但仅包含大小写字母、数字和下划线，并且总长度<=20 才满足代码块缓存机制。）。
    # '''
# 不同代码块下的缓存机制（小数据池机制）
    # '''
    # 小数据池，也称为小整数缓存机制，或者驻留机制等。
    # 在不同一个代码块内，对于整数、字符串：
    #     py自动将 -5 ~ 256 的整数进行了缓存，当这些整数赋值给变量时，并不会重新创建对象，而是使用已经创建好的缓存对象。
    #     py会将一定规则的字符串在字符串驻留池中创建一份，当你将这些字符串赋值给变量时，并不会重新创建对象，而是使用在字符串驻留池中创建好的缓存对象。
    #     无论是缓存还是字符串驻留池，都是py做的一个优化，就是将上述两种数据放在一个池中（容器、字典），程序中那些变量指向范围内的整数或字符串时，都是直接从池中引用。
    #     适用于： int(float)、str、bool

    #     也就是说，如果变量的赋值是在上述两种类型的范围里，且多个变量的值相等，那么意味着它们在内存中指向的都是一个内存地址。
    #         >>> l01 = 1024
    #         >>> l02 = 1024
    #         >>> id(l02)
    #         4346750160
    #         >>> id(l01)
    #         4346749328
    #         >>> l01 is l02
    #         False
    #         >>> l03 = 256
    #         >>> l04 = 256
    #         >>> id(l03)
    #         4345063824
    #         >>> id(l04)
    #         4345063824
    #         >>> l03 is l04
    #         True

    # 在一个文件中（同一代码块）中声明两个变量并赋值=='hadsf12398qgbasdfau哈哈h8hasdf'，并进行is判断。再去交互式分别赋值给两个变量后（不同代码块）进行is判断，会发现二者的区别。

    # '''
# 总结
# 集合 {}
    # 容器型数据类型。
    # 要求包含的数据都是不可变的（可哈希），但集合本身是可变的数据类型。
    # 集合是无序的。
    # 集合用{}表示， 如果{}中包含的是kv对，则表示dict；如果{}中包含的是元素，则表示set。
    # 集合的作用：1.列表的去重；2.关系测试（交集、并集、差集等）

# 集合的增删改查。集合不是用来增删改查而设计，集合是用来做交集、并集、差集等计算的。
    # 增 add()
        # >>> set1 = {'a','b','c','ee','dasdf'}
        # >>> set1.add('kk')
        # >>> set1
        # {'b', 'c', 'a', 'ee', 'kk', 'dasdf'}
    # 迭代着增加 update()
        # >>> set1
        # {'b', 'c', 'a', 'ee', 'kk', 'dasdf'}
        # >>> set1.update('哈你是时')
        # >>> set1
        # {'b', 'c', 'kk', 'ee', '哈', '你', 'a', 'dasdf', '时', '是'}
    # 删 按照元素删除 remove()
        # >>> set1.remove('kk')
        # >>> set1
        # {'b', 'c', 'ee', '哈', '你', 'a', 'dasdf', '时', '是'}
    # 删 随机删除一个元素 pop()
        # set1.pop()
    # 删除集合 del
        # del set1
        # >>> del set1
        # >>> set1
        # Traceback (most recent call last):
        #   File "<stdin>", line 1, in <module>
        # NameError: name 'set1' is not defined
    # 改
        # 没有直接改的方法，因为是无序的。
        # 但是可以先remove()源值，再add()目标值来实现。
# 集合的应用1：集合运算
    # 交集 &或者intersection()
        # >>> set1 = {1,2,3,4}
        # >>> set2 = {2,3,5,6,7}
        # >>> set1 & set2
        # {2, 3}
        # >>> set1.intersection(set2)
        # {2, 3}
    # 并集 |或者union()
        # >>> set1 | set2
        # {1, 2, 3, 4, 5, 6, 7}
        # >>> set1.union(set2)
        # {1, 2, 3, 4, 5, 6, 7}
    # 差集 -或者difference()
        # >>> set1 = {1,2,3,4}
        # >>> set2 = {2,3,5,6,7}
        # >>> set1 - set2
        # {1, 4}
        # >>> set2 - set1
        # {5, 6, 7}
    # 反交集 ^ 或者symmetric_difference() (并集减去交集)
        # >>> set1 = {1,2,3,4}
        # >>> set2 = {2,3,5,6,7}
        # >>> set1 ^ set2
        # {1, 4, 5, 6, 7}
        # >>> set2 ^ set1
        # {1, 4, 5, 6, 7}
    # 子集 <或者issubset()   
    # 超集 >或者issuperset()
        # >>> set1 = {1,2,3,4,5}
        # >>> set2 = {1,2,3,4,5,6,7,8,9}
        # >>> set1 > set2
        # False
        # >>> set1 < set2
        # True
        # >>> set2 > set1
        # True
    # 不可变集合
    # 集合的应用2：给列表去重，但不一定能保证列表原顺序。
        # >>> l1 = [1,1,1,1,2,2,2,2,3,3,3,4,4,5,5,6,7,7,7,8,9,4,4,5,2,3,4,'p',1,2,3,4,5,]
        # >>> set1 = set(l1)
        # >>> set1
        # {1, 2, 3, 4, 5, 6, 7, 8, 9, 'p'}
        # >>> l1 = list(set1)
        # >>> l1
        # [1, 2, 3, 4, 5, 6, 7, 8, 9, 'p']
# 深浅copy。（全copy和部分copy）
    # 赋值运算
        # >>> l1 = [1,2,3,[44,55],66]
        # >>> l2 = l1
        # >>> l1.append('aa')
        # >>> l2
        # [1, 2, 3, [44, 55], 66, 'aa']
        # >>> l1
        # [1, 2, 3, [44, 55], 66, 'aa']
        # 猜测：可变对象赋值给变量后，同id是同一个对象。对应的，将不可变对象赋值给变量后，变量修改值，其实就是换了一个对象，因此会变？
            # >>> l1='shd'
            # >>> l2=l1
            # >>> l1='aaa'
            # >>> l2
            # 'shd'
            # >>> l1
            # 'aaa'
    # 浅copy
    # 在内存中开辟一个新的空间存放copy的对象（list、dict），但是里面的所有元素与被copy对象里面的元素共用一个。
        # >>> l1 = [1,2,3,4,5,6] 
        # >>> l2 = l1.copy()
        # >>> l1.append(123)
        # >>> l2
        # [1, 2, 3, 4, 5, 6]
        # >>> l1
        # [1, 2, 3, 4, 5, 6, 123]
        # 浅copy时，就是将源列表包含的元素的内存指针，copy给目标，这样一来，浅copy时所包含的元素在两个对象中的地址是相同的，
        # 在任意列表中对【可变化元素】进行修改，都会从另一个列表中看到更改。但是同时，对任意列表进行append() ，都不会被另一个列表所看到，
        # 因为浅copy动作时，并不包含后续append的元素的内存地址。
        # 同样的，在任意列表中对【不可变化元素】进行赋值修改，那么另一个列表中也看不到变更，因为不可变化元素在内存中的地址是固定的，变量赋值更改的只是元素指向的内存地址变化。
    # 深copy，原则上所有元素都是另起炉灶的。
    # 不可变类型沿用之前的（因为不会变），对于可变类型完全创建全新的内存对象（地址也就不同了）
        # >>> import copy
        # >>> l1 = [1,2,3,[11,22,33,]]
        # >>> l2 = copy.deepcopy(l1)      # 深copy
        # >>> l3 = l1.copy()              # 浅copy
        # >>> print(id(l1),id(l2),id(l3))  # 看一下三个变量list的内存地址，各不相同。
        # 4346868608 4346919040 4346919168
        # >>> print(id(l1[0]),id(l2[0]),id(l3[0]))  # 看一下三个变量元素1（int，不可变元素）的内存地址，相同。
        # 4344867120 4344867120 4344867120
        # >>> print(id(l1[-1]),id(l2[-1]),id(l3[-1]))  # 看一下三个变量元素4（list，可变元素）的内存地址，可以发现 浅copy的list元素地址和源l1的对应元素一致，
        # 4345183808 4346225280 4345183808              #而深copy的list元素内存地址和源l1的对应元素内存地址不同。——这是py的一个优化。
        # >>> l1[-1].append('kk')                      # 对源l1里元素4的list做变更。
        # >>> print(id(l1[-1]),id(l2[-1]),id(l3[-1]))  # 再次查看各变量list里元素4的地址，可以看到和上面一样，浅copy的可变子元素内存地址 == 源子元素内存地址，深copy则另起炉灶。
        # 4345183808 4346225280 4345183808
        # >>> l1
        # [1, 2, 3, [11, 22, 33, 'kk']]             # 查看值也证明， 浅copy对其源，而深copy另起炉灶。
        # >>> l2
        # [1, 2, 3, [11, 22, 33]]                   # 深copy另起炉灶
        # >>> l3
        # [1, 2, 3, [11, 22, 33, 'kk']]
    # py对深copy做了优化，原则上深copy后所有元素都是单独一份存放的，但为了节省内存开支，py将不可变的数据类型沿用了同一个（目标、内存地址），只对可变数据类型做了各自单独一份。
        # l1 = [1, 2, 3, [11, 22, 33, 'kk']]
        # l2 = l1[:] , 切片方式默认就是浅copy，可以检查元素4的地址来判断，嵌套的数据类型是否为同一个，是得话就是浅copy，不是的话就是深copy。
            # >>> id(l4[-1])
            # 4345183808
            # >>> id(l1[-1])
            # 4345183808


# 作业
# 1. 用代码验证"name"是否在字典的key中？
# 2. 用代码验证"Kog"是否在字典的value中？
#   info = {'name':'Kog','hobby':'sleep','age':'18',...100个kv对}
# Q1. info['name'] 或者 >>> 'name' in info.keys()
# Q2. 'Kog' in info.values()

# 3. 有如下：
#   v1 = {'张毅','丈二','张三','张四'}
#   v2 = {'丈二','张四'}
#   求v1和v2的交集
#       v1 & v2,{'丈二', '张四'}
#   求v1和v2的并集
#       v1 | v2,{'张毅', '丈二', '张四', '张三'}
#   求v1和v2的差集
#       v1 - v2,{'张毅', '张三'}
#   求v2和v1的差集
#       v2 - v1,set()


# 4. 循环提示用户输入，并将输入内容追加到列表中，如果输入n或N则停止循环。
# list = []
# flag = True
# while flag:
#     v0 = input('type in something.-->')
#     if v0.upper() == 'N':
#         flag = False
#         print(list)
#         continue
#     else :
#         list.append(v0)

# 5. 循环提示用户输入，并将输入内容添加到集合中，如果输入n或者N则停止循环。
# set1 = set()  # set1 = {}
# flag = True
# while flag:
#     v1 = input('type in something.-->')
#     if v1.upper() == 'N':
#         flag = False
#         print(set1)
#         continue
#     else:
#         set1.add(v1)

# 6. 写代码实现
#   v1 = {'张毅','丈二','张四'}
#   v2 = []
#   循环提示用户输入，如果输入值在v1中存在，则追加到v2中，如果v1中不存在，则添加到v1中。
# v1 = {'张毅','丈二','张四'}
# v2 = []
# flag = True
# while flag:
#     v0 = input('type in something.-->')
#     if v0.upper() == 'N':
#         flag = False
#         print('v1:',v1)
#         print('v2:',v2)
#         continue
#     elif v0 in v1:
#         v2.append(v0)
#         print(v1,v2)
#     else: # v0 not in v1
#         v1.add(v0)
#         print(v1,v2)


# 7. 判断以下值哪个能做字典的的key？哪个能做集合的元素？
# 1, -1, "", None, [1,2], (1,), {11,22,33,4}, {'name':'abc','age':18}
    # 字典key不能是可变对象(tuple都可以！)，所以可以做字典key的有： 1, -1, 1, -1, "", None, (1,)
    # 可以做集合的对象也都是不可变对象，因此可以做为集合的元素与上面一样。


# 8. is 和 == 的区别？
    # is 判断内存地址是否相同。也就是比较两个对象的id值是否相等，相等意味着是同一个实例对象。
    # == 判断内容是否相同。比较两个对象的内容是否相等。
        # >>> a2 = 258   #(因为python3的小数据池缓存机制，大于256的数字并不在数据池中。赋值小于256时，会将变量指针指向数据池中的位置，因此内存地址相等。但是超出数据池范围，则指向各自的内存空间。)
        # >>> a1 = 258
        # >>> a1 == a2
        # True
        # >>> a1 is a2
        # False

# 9. type() 的使用方式及作用
    # 查看对象类型。
    # 进阶：返回一个类。

# 10. id() 的使用方式及作用
    # 返回对象的内存地址。

# 11. 看代码写结果并解释原因
# v1 = {'k1':'v1','k2':[1,2,3]}
# v2 = {'k1':'v1','k2':[1,2,3]}
# result1 = v1 == v2
    # True
# result2 = v1 is v2
    # False。 无论是否在同一代码块中（交互模式、文件模式），都是False，因为缓存机制对int、str和bool生效，对于dict和list，要看深浅copy：dict内的对象是被缓存的，但dict本身并不是相同的对象，只能是当前状态下相等的对象。
        # >>> v1 = {'k1':'v1','k2':[1,2,3],'k3':2580}
        # >>> v2 = {'k1':'v1','k2':[1,2,3],'k3':2580}
        # >>> v1['k3'] is v2['k3']
        # False
        # >>> v1['k1'] is v2['k1']
        # True

        # [11:27:31] kk@kkdeMacBook-Pro:/tmp $ cat t.py
        # v1 = {'k1':'v1','k2':[1,2,3],'k3':2580}
        # v2 = {'k1':'v1','k2':[1,2,3],'k3':2580}
        # print(v1['k3'] is v2['k3'])
        # [11:27:33] kk@kkdeMacBook-Pro:/tmp $ python3 t.py
        # True

# 12. 看代码写结果并解释原因
# v1 = {'k1':'v1','k2':[1,2,3]}
# v2 = v1
# result1 = v1 == v2
    # True。 两个对象相等
# result2 = v1 is v2
    # True。 v1和v2指向同一个dict对象的指针。所以内存对象地址是同一个。

# 13. 看代码写结果并解释原因
# v1 = {'k1':'v1','k2':[1,2,3]}
# v2 = v1
# v1['k1'] = 'abc'
# print(v2)
    # v2 == {'k1':'abc','k2':[1,2,3]}
    # 因为v1和v2拥有指向同一个dict对象的指针。

# 14. 看代码写结果并解释原因
# v1 = '人生苦短，我用py'
# v2 = [1,2,3,4,v1]
# v1 = '人生苦短，也不用py'
# print(v2)
    # v2不变。
    # 因为v2已经赋值了。
    # 在v1重新赋值之前，v2[-1]和v1指向的对象是同一个内存地址，
    # 在v1重新赋值后，v1指向了新的内存地址，而v2并没有重新赋值，因此v2不会因此而变化。


# 15. 看代码写结果并解释原因
# info = [1,2,3]
# userinfo = {'account':info,'num':info,'money':info}
# info.append(9)
# print(userinfo)
# info = 'lalalalalala'
# print(userinfo)
    # 第一个会变化，新增了9；第二个不会变化。
    # 因为第一个是对原有对象的更改（append），dict中指向的对象被更改了内容，但是指针没有变化，所以内容有变化。
    # 第二个操作更改了info变量的指向对象（变化了内存地址），但dict指针不变，指针的目标内存也没有变化，所以不受影响。


# 16. 看代码写结果并解释原因
# info = [1,2,3]
# userinfo = [info,info,info,info,info]
# info[0] = 'lalalalalalala'
# print(info,userinfo)
    # 都变。对原地址对象做了变更。

# 17. 看代码写结果并解释原因
# info = [1,2,3]
# userinfo = [info,info,info,info,info]
# info[2][0] = 'lalalalalalala'
# print(info,userinfo)
    # info[2][0] = 'lalalalalalala' 会报错。非法赋值。 结果不变。

# 18. 看代码写结果并解释原因
# info = [1,2,3]
# user_list = []
# for item in range(10):
#     user_list.append(info)

# info[1] = 'lalalalala'
# print(user_list)
    # user_list == [[1,'lalalalala',3],...x10]
    # 原地址对象做了改变。



# 19. 看代码写结果并解释原因
# date = {}
# for i in range(10):
#     date['user'] = i
# print(date)
    # date == {'user':9}



# 20. 看代码写结果并解释原因
# data_list = []
# data = {}
# for i in range(10):
#     data['user'] = i
#     data_list.append(data)
# print(data_list)
    # data_list == [{'user':9},...x10]
    # 注意，这里是不停的对data['user'] 进行修改，{'data':value} 中，value的值不断被更新，而kv的对象地址并没有变化，因此，append到data_list后的每一个元素指向的都是一个内存地址，地址对应的数据不断被刷新，直到最后一个结果。

# 21. 看代码写结果并解释原因
# data_list = []
# for i in range(10):
#     data = {}
#     data['user'] = i
#     data_list.append(data)
# print(data_list)
    # data_list == [{'user':0},...,{'user':9}]
    # 虽然是在一个代码块里，但是每次for循环中，都会重新对data赋值，而此时赋值为{}的data和
    # 上一次循环时已经包含'user' kv的dict对象不同，内存地址也不同了，
    # 因此，每次for循环中append到data_list中的data值都是独立的。


# 23. 敲七游戏。从1开始数，遇到7或者7的倍数，在桌子上敲一下。
# 给出任意数字n，从1开始数到n，把每个数字放入列表，遇到7或者7的倍数，则向列表中插入“咣”。
    # n = input('type:')
    # n = int(n)    # n = 100
    # result = []
    # for i in range(1,n+1):
    #     if i == 7 or i % 7 == 0:
    #         result.append('咣当！')
    #         # continue
    #     else:
    #         result.append(i)

    # print(result)

